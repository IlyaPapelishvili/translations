# Выпуск Rust 1.42.0: шаблоны срезов, более удобные сообщения о панике

Команда Rust рада сообщить о выпуске новой версии, 1.42.0. Rust — это язык программирования, позволяющий каждому создавать надёжное и эффективное программное обеспечение.

Если вы установили предыдущую версию Rust средствами `rustup`, то для обновления до версии 1.42.0 вам достаточно выполнить следующую команду:

```console
rustup update stable
```

Если у вас ещё не установлен `rustup`, вы можете [установить его](https://www.rust-lang.org/install.html) с соответствующей страницы нашего веб-сайта, а также посмотреть [подробные примечания к выпуску](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1420-2020-03-12) на GitHub.

## Что вошло в стабильную версию 1.42.0

Основными нововведениями Rust 1.42.0 являются более удобные сообщения о панике в случае вызова `unwrap`, шаблоны срезов, объявление устаревшим `Error::description` и многое другое. Смотрите [подробности выпуска](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1420-2020-03-12) для дополнительной информации.

### Useful line numbers in `Option` and `Result` panic messages

In Rust 1.41.1, calling `unwrap()` on an `Option::None` value would produce an error message looking something like this:

```
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', /.../src/libcore/macros/mod.rs:15:40
```

Similarly, the line numbers in the panic messages generated by `unwrap_err`, `expect`, and `expect_err`, and the corresponding methods on the `Result` type, also refer to `core` internals.

In Rust 1.42.0, all eight of these functions produce panic messages that provide the line number where they were invoked. The new error messages look something like this:

```
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/main.rs:2:5
```

This means that the invalid call to `unwrap` was on line 2 of `src/main.rs`.

This behavior is made possible by an annotation, `#[track_caller]`. This annotation is not yet available to use in stable Rust; if you are interested in using it in your own code, you can follow its progress by watching [this tracking issue](https://github.com/rust-lang/rust/issues/47809).

### Subslice patterns

In Rust 1.26, we stabilized "[slice patterns](https://blog.rust-lang.org/2018/05/10/Rust-1.26.html#basic-slice-patterns)," which let you `match` on slices. They looked like this:

```rust
fn foo(words: &[&str]) {
    match words {
        [] => println!("empty slice!"),
        [one] => println!("one element: {:?}", one),
        [one, two] => println!("two elements: {:?} {:?}", one, two),
        _ => println!("I'm not sure how many elements!"),
    }
}
```

This allowed you to match on slices, but was fairly limited. You had to choose the exact sizes you wished to support, and had to have a catch-all arm for size you didn't want to support.

В Rust 1.42 у нас теперь есть [расширенная поддержка сопоставления с частью среза](https://github.com/rust-lang/rust/pull/67712/):

```rust
fn foo(words: &[&str]) {
    match words {
        ["Hello", "World", "!", ..] => println!("Hello World!"),
        ["Foo", "Bar", ..] => println!("Baz"),
        rest => println!("{:?}", rest),
    }
}
```

The `..` is called a "rest pattern," because it matches the rest of the slice. The above example uses the rest pattern at the end of a slice, but you can also use it in other ways:

```rust
fn foo(words: &[&str]) {
    match words {
        // Игнорируем всё, за исключением последнего элемента, который должен быть "!".
        [.., "!"] => println!("!!!"),

        // `start` - это срез из всех элементов, кроме последнего, который должен быть "z".
        [start @ .., "z"] => println!("starts with: {:?}", start),

        // `end` - это срез из всех элементов, кроме первого, который должен быть "a".
        ["a", end @ ..] => println!("ends with: {:?}", end),

        rest => println!("{:?}", rest),
    }
}
```

If you're interested in learning more, we published [a post on the Inside Rust blog](https://blog.rust-lang.org/inside-rust/2020/03/04/recent-future-pattern-matching-improvements.html) discussing these changes as well as more improvements to pattern matching that we may bring to stable in the future! You can also read more about slice patterns in [Thomas Hartmann's post](https://thomashartmann.dev/blog/feature(slice_patterns)/).

### [`matches!`](https://doc.rust-lang.org/stable/std/macro.matches.html)

Этот релиз языка Rust стабилизирует новый макрос, [`matches!`](https://doc.rust-lang.org/nightly/std/macro.matches.html). Этот макрос принимает выражение и образец, и возвращает `true`, если образец сопоставим с выражением. Другими словами:

```rust
// Используя выражение match:
match self.partial_cmp(other) {
    Some(Less) => true,
    _ => false,
}

// Используя макрос `matches!`:
matches!(self.partial_cmp(other), Some(Less))
```

Вы можете также использовать образцы с `|` и условные ограничения `if`:

```rust
let foo = 'f';
assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));

let bar = Some(4);
assert!(matches!(bar, Some(x) if x > 2));
```

### `use proc_macro::TokenStream;` now works

In Rust 2018, we [removed the need for `extern crate`](https://doc.rust-lang.org/stable/edition-guide/rust-2018/module-system/path-clarity.html#no-more-extern-crate). But procedural macros were a bit special, and so when you were writing a procedural macro, you still needed to say `extern crate proc_macro;`.

In this release, if you are using Cargo, [you no longer need this line when working with the 2018 edition; you can use `use` like any other crate](https://github.com/rust-lang/cargo/pull/7700). Given that most projects will already have a line similar to `use proc_macro::TokenStream;`, this change will mean that you can delete the `extern crate proc_macro;` line and your code will still work. This change is small, but brings procedural macros closer to regular code.

### Libraries

- [`[iter::Empty<T>](https://github.com/rust-lang/rust/pull/68348/)` now implements `Send` and `Sync` for any `T`.](https://github.com/rust-lang/rust/pull/68348/)
- [`[Pin::{map_unchecked, map_unchecked_mut}](https://github.com/rust-lang/rust/pull/67935/)` no longer require the return type to implement `Sized`.](https://github.com/rust-lang/rust/pull/67935/)
- [`[io::Cursor](https://github.com/rust-lang/rust/pull/67233/)` now implements `PartialEq` and `Eq`.](https://github.com/rust-lang/rust/pull/67233/)
- [`[Layout::new](https://github.com/rust-lang/rust/pull/66254/)` is now `const`.](https://github.com/rust-lang/rust/pull/66254/)

### Stabilized APIs

- [`CondVar::wait_while`](https://doc.rust-lang.org/stable/std/sync/struct.Condvar.html#method.wait_while) & [`CondVar::wait_timeout_while`](https://doc.rust-lang.org/stable/std/sync/struct.Condvar.html#method.wait_timeout_while)
- [`DebugMap::key`](https://doc.rust-lang.org/stable/std/fmt/struct.DebugMap.html#method.key) & [`DebugMap::value`](https://doc.rust-lang.org/stable/std/fmt/struct.DebugMap.html#method.value)
- [`ManuallyDrop::take`](https://doc.rust-lang.org/stable/std/mem/struct.ManuallyDrop.html#method.take)
- [`ptr::slice_from_raw_parts_mut`](https://doc.rust-lang.org/stable/std/ptr/fn.slice_from_raw_parts_mut.html) & [`ptr::slice_from_raw_parts`](https://doc.rust-lang.org/stable/std/ptr/fn.slice_from_raw_parts.html)

### Other changes

There are other changes in the Rust 1.42.0 release: check out what changed in [Rust](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1420-2020-03-12) and [Cargo](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-142-2020-03-12).

### Compatibility Notes

We have two notable compatibility notes this release: a deprecation in the standard library, and a demotion of 32-bit Apple targets to Tier 3.

#### Error::Description is deprecated

Sometimes, mistakes are made. The `Error::description` method is now considered to be one of those mistakes. The problem is with its type signature:

```rust
fn description(&self) -> &str
```

Because `description` returns a `&str`, it is not nearly as useful as we wished it would be. This means that you basically need to return the contents of an `Error` verbatim; if you wanted to say, use formatting to produce a nicer description, that is impossible: you'd need to return a `String`. Instead, error types should implement the `Display`/`Debug` traits to provide the description of the error.

This API has existed since Rust 1.0. We've been working towards this goal for a long time: back in Rust 1.27, we ["soft deprecated" this method](https://github.com/rust-lang/rust/pull/50163). What that meant in practice was, we gave the function a default implementation. This means that users were no longer forced to implement this method when implementing the `Error` trait. In this release, [we mark it as *actually* deprecated](https://github.com/rust-lang/rust/pull/66919/), and took some steps to de-emphasize the method in `Error`'s documentation. Due to our stability policy, `description` will never be removed, and so this is as far as we can go.

#### Downgrading 32-bit Apple targets

Apple is no longer supporting 32-bit targets, and so, neither are we. They have been downgraded to Tier 3 support by the project. For more details on this, check out [this post](https://blog.rust-lang.org/2020/01/03/reducing-support-for-32-bit-apple-targets.html) from back in January, which covers everything in detail.

## Участники 1.42.0

Множество людей собрались вместе, чтобы создать Rust 1.42.0. Мы не смогли бы сделать это без всех вас, [спасибо](https://thanks.rust-lang.org/rust/1.42.0/)!
