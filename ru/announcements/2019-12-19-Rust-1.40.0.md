Команда Rust рада сообщить о выпуске новой версии, 1.40.0. Rust — это язык программирования, позволяющий каждому создавать надёжное и эффективное программное обеспечение.

Если вы установили предыдущую версию Rust средствами `rustup`, то для обновления до версии 1.40.0 вам достаточно выполнить следующую команду:

```console
$ rustup update stable
```

Если у вас ещё не установлен `rustup`, вы можете [установить его](https://www.rust-lang.org/install.html) с соответствующей страницы нашего веб-сайта, а также посмотреть [подробные примечания к выпуску](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1400-2019-12-19) на GitHub.

## Что вошло в стабильную версию 1.40.0

The highlights of Rust 1.40.0 include `#[non_exhaustive]` and improvements to `macros!()` and `#[attribute]`s. Finally, borrow-check migration warnings have become hard errors in Rust 2015. See the [detailed release notes](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1400-2019-12-19) for additional information.

### `#[non_exhaustive]` structs, enums, and variants

Suppose you're a library author of a crate `alpha`, that has a `pub struct Foo`. You would like to make `alpha::Foo`'s fields `pub` as well, but you're not sure whether you might be adding more fields to `Foo` in future releases. So now you have a dilemma: either you make the fields private, with the drawbacks that follow, or you risk users depending on the exact fields, breaking their code when you add a new one. Rust 1.40.0 introduces a way to break the logjam: `#[non_exhaustive]`.

The attribute `#[non_exhaustive]`, when attached to a `struct` or the variant of an `enum`, will prevent code outside of the crate defining it from constructing said `struct` or variant. To avoid future breakage, other crates are also prevented from exhaustively matching on the fields. The following example illustrates errors in `beta` which depends on `alpha`:

```rust
// alpha/lib.rs:

#[non_exhaustive]
struct Foo {
    pub a: bool,
}

enum Bar {
    #[non_exhaustive]
    Variant { b: u8 }
}

fn make_foo() -> Foo { ... }
fn make_bar() -> Bar { ... }

// beta/lib.rs:

let x = Foo { a: true }; //~ ERROR
let Foo { a } = make_foo(); //~ ERROR
let Foo { a, .. } = make_foo(); //~ OK
          // -- `beta` will still compile when more fields are added.

let x = Bar::Variant { a: 42 }; //~ ERROR
let Bar::Variant { b } = make_bar(); //~ ERROR
let Bar::Variant { b, .. } = make_bar(); //~ OK
                   // -- `beta` will still compile...
```

What happens behind the scenes is that the visibility of the constructors for a `#[non_exhaustive]` `struct` or `enum` variant is lowered to `pub(crate)`, preventing access outside the crate defining it.

A perhaps more important aspect of `#[non_exhaustive]` is that it can also be attached to `enum`s themselves. An example, taken from the standard library, is [`Ordering`](https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html):

```rust
#[non_exhaustive]
pub enum Ordering { Relaxed, Release, Acquire, AcqRel, SeqCst }
```

The purpose of `#[non_exhaustive]` in this context is to ensure that more variants can be added over time. This is achieved by preventing other crates from exhaustively pattern `match`-ing on `Ordering`. That is, the compiler would reject:

```rust
match ordering {
    Relaxed | Release | Acquire | AcqRel | SeqCst => { /* logic */ }
    //~^ ERROR; since if a new variant is added,
    // this would suddenly break if there wasn't an error to begin with.
}
```

Instead, other crates need to account for the possibility of more variants by adding a wildcard arm using e.g. `_`:

```rust
match ordering {
    Relaxed | Release | Acquire | AcqRel | SeqCst => { /* logic */ }
    _ => { /* logic */ } // OK; if more variants are added, nothing will break.
}
```

For more details on the `#[non_exhaustive]` attribute, see the [stabilization report](https://github.com/rust-lang/rust/issues/44109#issuecomment-533356866).

### Macro and attribute improvements

In 1.40.0, we have introduced several improvements to macros and attributes, including:

- [Calling procedural macros `mac!()` in type contexts.](https://github.com/rust-lang/rust/pull/63931/#issuecomment-526362396)

    For example, you may write `type Foo = expand_to_type!(bar);` where `expand_to_type` would be a procedural macro.

- [Macros in `extern { ... }` blocks.](https://github.com/rust-lang/rust/pull/63931/#issuecomment-526362396)

    This includes `bang!()` macros, for example:

    ```rust
    macro_rules! make_item { ($name:ident) => { fn $name(); } }

    extern {
        make_item!(alpha);
        make_item!(beta);
    }
    ```

    Procedural macro attributes on items in [`extern { ... }` blocks](https://doc.rust-lang.org/nightly/reference/items/external-blocks.html) are now also supported:

    ```rust
    extern "C" {
        #[my_identity_macro] //~ Let's assume that this expands to `fn foo();`.
        fn foo();
    }
    ```

- [Generating `macro_rules!` items in procedural macros.](https://github.com/rust-lang/rust/pull/64035#issuecomment-533890826)

    Function-like (`mac!()`) and attribute (`#[mac]`) macros can both now generate `macro_rules!` items. For details on hygiene, please refer to the attached stabilization report.

- [The `$m:meta` matcher](https://github.com/rust-lang/rust/pull/63674) supports [arbitrary token-stream values](https://github.com/rust-lang/rust/pull/57367#issuecomment-457882109).

    That is, the following is now valid:

    ```rust
    macro_rules! accept_meta { ($m:meta) => {} }
    accept_meta!( my::path );
    accept_meta!( my::path = "lit" );
    accept_meta!( my::path ( a b c ) );
    accept_meta!( my::path [ a b c ] );
    accept_meta!( my::path { a b c } );
    ```

### Borrow check migration warnings are hard errors in Rust 2015

In the 1.35.0 release, [we announced](https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html#nll-for-rust-2015) that NLL had come to Rust 2015 after first being released for the 2018 edition in [Rust 1.31](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes).

As we noted back then, the old borrow checker had some bugs which would allow memory unsafety, and the NLL borrow checker fixed them. As these fixes break some stable code, we decided to gradually phase in the errors, by checking if the old borrow checker would accept the program and the NLL checker would reject it. In those cases, the errors would be downgraded to warnings.

The previous release, Rust 1.39.0, changes these warnings into errors for code using the [2018 edition](https://github.com/rust-lang/rust/pull/63565). Rust 1.40.0 applies the same change for users of the [2015 edition](https://github.com/rust-lang/rust/pull/64221), closing those soundness holes for good. This has also the side effect of [cleaning up the old code from the compiler](https://github.com/rust-lang/rust/pull/64790).

If your build breaks due to this change, or you want to hear more, check out [Niko Matsakis's blog post](https://blog.rust-lang.org/2019/11/01/nll-hard-errors.html).

### Больше константных функций в стандартной библиотеке

Начиная с Rust 1.40.0, следующие функции помечены как константные (`const fn`):

- [`is_power_of_two`](https://doc.rust-lang.org/std/primitive.u8.html#method.is_power_of_two) для [беззнаковых целых чисел](https://github.com/rust-lang/rust/pull/65092)

### Стабилизированные функции в стандартной библиотеке

В Rust 1.40.0 были стабилизированы следующие функции:

- [`todo!`](https://doc.rust-lang.org/std/macro.todo.html)

    Более короткая, запоминающаяся и удобная версия макроса [`unimplemented!()`](https://doc.rust-lang.org/std/macro.unimplemented.html).

- [`slice::repeat`](https://doc.rust-lang.org/std/primitive.slice.html#method.repeat)

    Создаёт `Vec<T>` из `n` повторений среза.

- [`mem::take`](https://doc.rust-lang.org/std/mem/fn.take.html)

    Эта функция забирает значения из изменяемой ссылки и заменяет их значением по умолчанию для данного типа. Она похожа на [`Option::take`](https://doc.rust-lang.org/std/option/enum.Option.html#method.take) и [`Cell::take`](https://doc.rust-lang.org/std/cell/struct.Cell.html#method.take) и является удобным сокращением для [`mem::replace(&mut dst, Default::default())`](https://doc.rust-lang.org/std/mem/fn.replace.html).

- [`BTreeMap::get_key_value`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.get_key_value) и [`HashMap::get_key_value`](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get_key_value)

    Возвращает пару ключ-значение, соответствующие представленному ключу.

- [`Option::as_deref`](https://doc.rust-lang.org/std/option/enum.Option.html#method.as_deref), [`Option::as_deref_mut`](https://doc.rust-lang.org/std/option/enum.Option.html#method.as_deref_mut)

    These work similarly to [`Option::as_ref`](https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref) and [`Option::as_mut`](https://doc.rust-lang.org/std/option/enum.Option.html#method.as_mut) but also use [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html) and [`DerefMut`](https://doc.rust-lang.org/std/ops/trait.DerefMut.html) respectively, so that `opt_box.as_deref()` and `opt_box.as_deref_mut()`, where `opt_box: Option<Box<T>>`, produce an `Option<&T>` and `Option<&mut T>` respectively.

- [`Option::flatten`](https://doc.rust-lang.org/std/option/enum.Option.html#method.flatten)

    Эта функция разворачивает (выравнивает) `Option<Option<T>>` в `Option<T>` производя `Some(x)` для `Some(Some(x))` и `None` в противном случае. Эта функция похожа на [`Iterator::flatten`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flatten).

- [`UdpSocket::peer_addr`](https://doc.rust-lang.org/std/net/struct.UdpSocket.html#method.peer_addr)

    Возвращает адрес сокета удалённого узла, к которому подключен этот сокет.

- [`{f32,f64}::to_be_bytes`](https://doc.rust-lang.org/std/primitive.f32.html#method.to_be_bytes), [`{f32,f64}::to_le_bytes`](https://doc.rust-lang.org/std/primitive.f32.html#method.to_le_bytes),[`{f32,f64}::to_ne_bytes`](https://doc.rust-lang.org/std/primitive.f32.html#method.to_ne_bytes), [`{f32,f64}::from_be_bytes`](https://doc.rust-lang.org/std/primitive.f32.html#method.from_be_bytes), [`{f32,f64}::from_le_bytes`](https://doc.rust-lang.org/std/primitive.f32.html#method.from_le_bytes) и [`{f32,f64}::from_ne_bytes`](https://doc.rust-lang.org/std/primitive.f32.html#method.from_ne_bytes)

    Возвращают представление в памяти числа с плавающей точкой в виде массива байт с big-endian (network), little-endian или native-endian порядком байт.

### Другие изменения

[Синтаксис](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1400-2019-12-19), [пакетный менеджер Cargo](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-140-2019-12-19) и [анализатор Clippy](https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-140) также претерпели некоторые изменения.

Пожалуйста, прочтите [заметки о совместимости](https://github.com/rust-lang/rust/blob/stable/RELEASES.md#compatibility-notes), чтобы узнать, затронут ли вас эти изменения.

## Участники 1.40.0

Множество людей собрались вместе, чтобы создать Rust 1.40.0. Мы не смогли бы сделать это без всех вас, [спасибо](https://thanks.rust-lang.org/rust/1.40.0/)!
