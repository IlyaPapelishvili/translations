Команда Rust рада сообщить о выпуске новой версии, 1.40.0. Rust — это язык программирования, позволяющий каждому создавать надёжное и эффективное программное обеспечение.

Если вы установили предыдущую версию Rust средствами `rustup`, то для обновления до версии 1.40.0 вам достаточно выполнить следующую команду:

```console
$ rustup update stable
```

Если у вас ещё не установлен `rustup`, вы можете [установить его](https://www.rust-lang.org/install.html) с соответствующей страницы нашего веб-сайта, а также посмотреть [подробные примечания к выпуску](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1400-2019-12-19) на GitHub.

## Что вошло в стабильную версию 1.40.0

Основными моментами обновления Rust 1.40.0 являются введение `#[non_exhaustive]` и улучшения `macros!()` и `#[attribute]`s. Наконец, миграционные предупреждения проверки заимствований (borrow check) стали серьезными ошибками в Rust 2015. Смотрите [подробности релиза](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1400-2019-12-19) для дополнительной информации.

### `#[non_exhaustive]` структуры, перечисления и варианты перечислений

Suppose you're a library author of a crate `alpha`, that has a `pub struct Foo`. You would like to make `alpha::Foo`'s fields `pub` as well, but you're not sure whether you might be adding more fields to `Foo` in future releases. So now you have a dilemma: either you make the fields private, with the drawbacks that follow, or you risk users depending on the exact fields, breaking their code when you add a new one. Rust 1.40.0 introduces a way to break the logjam: `#[non_exhaustive]`.

The attribute `#[non_exhaustive]`, when attached to a `struct` or the variant of an `enum`, will prevent code outside of the crate defining it from constructing said `struct` or variant. To avoid future breakage, other crates are also prevented from exhaustively matching on the fields. The following example illustrates errors in `beta` which depends on `alpha`:

```rust
// alpha/lib.rs:

#[non_exhaustive]
struct Foo {
    pub a: bool,
}

enum Bar {
    #[non_exhaustive]
    Variant { b: u8 }
}

fn make_foo() -> Foo { ... }
fn make_bar() -> Bar { ... }

// beta/lib.rs:

let x = Foo { a: true }; //~ ОШИБКА
let Foo { a } = make_foo(); //~ ОШИБКА
let Foo { a, .. } = make_foo(); //~ OK
          // -- `beta` все еще будет компилироваться при добавлении полей.

let x = Bar::Variant { a: 42 }; //~ ОШИБКА
let Bar::Variant { b } = make_bar(); //~ ОШИБКА
let Bar::Variant { b, .. } = make_bar(); //~ OK
                   // -- `beta` все еще будет компилироваться...
```

Что же происзодит за кулисами? Видимость конструкторов для структуры или варианта перечисления, помеченного с помощью `#[non_exhaustive]`, будет понижена до `pub(crate)`, предотвращая доступ извне пакета, в котором они были определены.

A perhaps more important aspect of `#[non_exhaustive]` is that it can also be attached to `enum`s themselves. An example, taken from the standard library, is [`Ordering`](https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html):

```rust
#[non_exhaustive]
pub enum Ordering { Relaxed, Release, Acquire, AcqRel, SeqCst }
```

Целью `#[non_exhaustive]` в этом случае является гарантия возможности добавления новых вариантов со временем. Это достигается благодаря предотвращению доступа другим пакетам к exhaustively pattern `match`-ing для `Ordering`. То есть, компилятор бы отклонил следующее:

```rust
match ordering {
    Relaxed | Release | Acquire | AcqRel | SeqCst => { /* logic */ }
    //~^ ОШИБКА; если новый вариант был бы добавлен,
    // это сломалось бы, если ошибки не было бы с самого начала.
}
```

Вместо этого другие пакеты теперь должны учитывать возможный вариант добавления новых вариантов перечисления, например добавляя подстановочный знак `_`:

```rust
match ordering {
    Relaxed | Release | Acquire | AcqRel | SeqCst => { /* logic */ }
    _ => { /* logic */ } // OK; если будут добавлены новые варианты, ничего не сломается.
}
```

Для более подробной информации об атрибуте `#[non_exhaustive]`, смотрите [отчет о стабилизации](https://github.com/rust-lang/rust/issues/44109#issuecomment-533356866).

### Macro and attribute improvements

In 1.40.0, we have introduced several improvements to macros and attributes, including:

- [Calling procedural macros `mac!()` in type contexts.](https://github.com/rust-lang/rust/pull/63931/#issuecomment-526362396)

    For example, you may write `type Foo = expand_to_type!(bar);` where `expand_to_type` would be a procedural macro.

- [Macros in `extern { ... }` blocks.](https://github.com/rust-lang/rust/pull/63931/#issuecomment-526362396)

    Этот блок включает макросы `bang!()`. Например:

    ```rust
    macro_rules! make_item { ($name:ident) => { fn $name(); } }

    extern {
        make_item!(alpha);
        make_item!(beta);
    }
    ```

    Procedural macro attributes on items in [`extern { ... }` blocks](https://doc.rust-lang.org/nightly/reference/items/external-blocks.html) are now also supported:

    ```rust
    extern "C" {
        #[my_identity_macro] //~ Давайте предположим, что это расширяется до `fn foo();`.
        fn foo();
    }
    ```

- [Generating `macro_rules!` items in procedural macros.](https://github.com/rust-lang/rust/pull/64035#issuecomment-533890826)

    Function-like (`mac!()`) and attribute (`#[mac]`) macros can both now generate `macro_rules!` items. For details on hygiene, please refer to the attached stabilization report.

- [The `$m:meta` matcher](https://github.com/rust-lang/rust/pull/63674) supports [arbitrary token-stream values](https://github.com/rust-lang/rust/pull/57367#issuecomment-457882109).

    That is, the following is now valid:

    ```rust
    macro_rules! accept_meta { ($m:meta) => {} }
    accept_meta!( my::path );
    accept_meta!( my::path = "lit" );
    accept_meta!( my::path ( a b c ) );
    accept_meta!( my::path [ a b c ] );
    accept_meta!( my::path { a b c } );
    ```

### Миграционные предупреждения проверки заимствований (borrow check) становятся серьезными ошибками в Rust 2015

В релизе 1.35.0 [мы сообщили](https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html#nll-for-rust-2015), что NLL появился в Rust 2015 после первого выпуска для 2018 редакции в [Rust 1.31](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes).

Как мы сообщали тогда, старый проверщик заимствований мог допустить небезопасное управление памятью, и с помощью нового проверщика (NLL borrow checker) эти ошибки были решены. Так как эти ошибки могли нарушить работу стабильного кода, мы решили постепенно вводить эти ошибки, проверяя, разрешит ли сборку программы старый проверщик, и запретит ли ее новый. В этих случаях ошибки заменялись предупреждениями.

Прошлый релиз, Rust 1.39.0, заменил эти предупреждения на ошибки для кода, использующего [2018 редакцию](https://github.com/rust-lang/rust/pull/63565). Rust 1.40.0 применит те же самые изменения для кода [2015 редакции](https://github.com/rust-lang/rust/pull/64221), закрывая эти дыры в безопасности навсегда. Также это имеет побочный эффект в виде [чистки компилятора от старого кода](https://github.com/rust-lang/rust/pull/64790).

Если ваш проект не собирается из-за этих изменений, или вы хотите узнать больше, посмотрите [пост Niko Matsakis's](https://blog.rust-lang.org/2019/11/01/nll-hard-errors.html).

### Больше константных функций в стандартной библиотеке

Начиная с Rust 1.40.0, следующие функции помечены как константные (`const fn`):

- [`is_power_of_two`](https://doc.rust-lang.org/std/primitive.u8.html#method.is_power_of_two) для [беззнаковых целых чисел](https://github.com/rust-lang/rust/pull/65092)

### Стабилизированные функции в стандартной библиотеке

В Rust 1.40.0 были стабилизированы следующие функции:

- [`todo!`](https://doc.rust-lang.org/std/macro.todo.html)

    Более короткая, запоминающаяся и удобная версия макроса [`unimplemented!()`](https://doc.rust-lang.org/std/macro.unimplemented.html).

- [`slice::repeat`](https://doc.rust-lang.org/std/primitive.slice.html#method.repeat)

    Создаёт `Vec<T>` из `n` повторений среза.

- [`mem::take`](https://doc.rust-lang.org/std/mem/fn.take.html)

    Эта функция забирает значения из изменяемой ссылки и заменяет их значением по умолчанию для данного типа. Она похожа на [`Option::take`](https://doc.rust-lang.org/std/option/enum.Option.html#method.take) и [`Cell::take`](https://doc.rust-lang.org/std/cell/struct.Cell.html#method.take) и является удобным сокращением для [`mem::replace(&mut dst, Default::default())`](https://doc.rust-lang.org/std/mem/fn.replace.html).

- [`BTreeMap::get_key_value`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.get_key_value) и [`HashMap::get_key_value`](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get_key_value)

    Возвращает пару ключ-значение, соответствующие представленному ключу.

- [`Option::as_deref`](https://doc.rust-lang.org/std/option/enum.Option.html#method.as_deref), [`Option::as_deref_mut`](https://doc.rust-lang.org/std/option/enum.Option.html#method.as_deref_mut)

    These work similarly to [`Option::as_ref`](https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref) and [`Option::as_mut`](https://doc.rust-lang.org/std/option/enum.Option.html#method.as_mut) but also use [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html) and [`DerefMut`](https://doc.rust-lang.org/std/ops/trait.DerefMut.html) respectively, so that `opt_box.as_deref()` and `opt_box.as_deref_mut()`, where `opt_box: Option<Box<T>>`, produce an `Option<&T>` and `Option<&mut T>` respectively.

- [`Option::flatten`](https://doc.rust-lang.org/std/option/enum.Option.html#method.flatten)

    Эта функция разворачивает (выравнивает) `Option<Option<T>>` в `Option<T>` производя `Some(x)` для `Some(Some(x))` и `None` в противном случае. Эта функция похожа на [`Iterator::flatten`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flatten).

- [`UdpSocket::peer_addr`](https://doc.rust-lang.org/std/net/struct.UdpSocket.html#method.peer_addr)

    Возвращает адрес сокета удалённого узла, к которому подключен этот сокет.

- [`{f32,f64}::to_be_bytes`](https://doc.rust-lang.org/std/primitive.f32.html#method.to_be_bytes), [`{f32,f64}::to_le_bytes`](https://doc.rust-lang.org/std/primitive.f32.html#method.to_le_bytes),[`{f32,f64}::to_ne_bytes`](https://doc.rust-lang.org/std/primitive.f32.html#method.to_ne_bytes), [`{f32,f64}::from_be_bytes`](https://doc.rust-lang.org/std/primitive.f32.html#method.from_be_bytes), [`{f32,f64}::from_le_bytes`](https://doc.rust-lang.org/std/primitive.f32.html#method.from_le_bytes) и [`{f32,f64}::from_ne_bytes`](https://doc.rust-lang.org/std/primitive.f32.html#method.from_ne_bytes)

    Возвращают представление в памяти числа с плавающей точкой в виде массива байт с big-endian (network), little-endian или native-endian порядком байт.

### Другие изменения

[Синтаксис](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1400-2019-12-19), [пакетный менеджер Cargo](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-140-2019-12-19) и [анализатор Clippy](https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-140) также претерпели некоторые изменения.

Пожалуйста, прочтите [заметки о совместимости](https://github.com/rust-lang/rust/blob/stable/RELEASES.md#compatibility-notes), чтобы узнать, затронут ли вас эти изменения.

## Участники 1.40.0

Множество людей собрались вместе, чтобы создать Rust 1.40.0. Мы не смогли бы сделать это без всех вас, [спасибо](https://thanks.rust-lang.org/rust/1.40.0/)!
