Команда Rust рада объявить о новой версии Rust, 1.41.1. Rust - это язык программирования, который позволяет каждому создавать надежное и эффективное программное обеспечение.

Если вы установили предыдущую версию Rust средствами `rustup`, то для обновления до версии 1.41.0 вам достаточно выполнить следующую команду:

```console
rustup update stable
```

Если у вас ещё не установлен `rustup`, вы можете [установить его](https://www.rust-lang.org/install.html) с соответствующей страницы нашего веб-сайта, а также посмотреть [подробные примечания к выпуску](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1410-2020-01-30) на GitHub.

## Что вошло в стабильную версию 1.41.0

The highlights of Rust 1.41.0 include relaxed restrictions for trait implementations, improvements to `cargo install`, a more `git`-friendly `Cargo.lock`, and new FFI-related guarantees for `Box<T>`. See the [detailed release notes](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1410-2020-01-30) to learn about other changes not covered by this post.

### Ослабление запретов при реализации типажей

Для предотвращения поломок в экосистеме, когда зависимость добавляет новые реализации типажа, Rust использует [*orphan rule*](https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type). Суть в том, что реализация типажа допустима только если типаж или тип, который его реализует, является локальным, т.е. определённым в текущем крейте.  [Однако это достаточно сложно](https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence), когда используются обобщения.

До версии Rust 1.41.0 это правило было слишком строгим, мешая композиции. Например, предположим что ваш пакет реализует структуру `BetterVec<T>`, и Вы хотите иметь возможность конвертации его в `Vec<T>` из стандартной библиотеки. Вы бы написали следующий код:

```rust
impl<T> From<BetterVec<T>> for Vec<T> {
    // ...
}
```

...который является примером паттерна:

```rust
impl<T> ForeignTrait<LocalType> for ForeignType<T> {
    // ...
}
```

В версии Rust 1.40.0 этот `impl` был запрещен правилом сироты (orphan rule), так как `From` и `Vec` определены в стандартной библиотеке, которая является чужим крейтом по отношению к текущему крейту. Были способы обойти это ограничение, такие как [*newtype* pattern](https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types), но они часто были громоздкими или даже невозможными в некоторых случаях.

While it's still true that both `From` and `Vec` were foreign, the trait (in this case `From`) was parameterized by a local type. Therefore, Rust 1.41.0 allows this `impl`.

Для более подробной информации читайте [отчет о стабилизации](https://github.com/rust-lang/rust/issues/63599) и [предложение RFC](https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html).

### `cargo install` обновляет пакеты если они устарели

При помощи `cargo install` вы можете установить в систему исполняемый крейт. Эта команда часто используется для установки популярных CLI-инструментов, созданных комьюнити и написанных на Rust.

Начиная с Rust 1.41.0, `cargo install` также может обновлять установленные крейты, если с момента установки появился новый релиз. До этого выпуска единственным возможным вариантом было использование флага `--force`, который позволял переустановить исполняемый крейт даже если он не нуждался в обновлении.

### Менее конфликтный формат `Cargo.lock`

To ensure consistent builds, Cargo uses a file named `Cargo.lock`, containing dependency versions and checksums. Unfortunately, the way the data was arranged in it caused unnecessary merge conflicts when changing dependencies in separate branches.

Rust 1.41.0 представляет новый формат для этого файла, разработанный специально для уменьшения конфликтов. Новый формат будет использоваться для всех новых `lock`-файлов, в то время как существующие файлы будут использовать предыдущий формат. Узнать больше о вариантах, которые привели к новому формату, вы можете [в PR, в котором его добавили](https://github.com/rust-lang/cargo/pull/7070).

### More guarantees when using `Box<T>` in FFI

Starting with Rust 1.41.0, we have declared that a `Box<T>`, where `T: Sized` is now ABI compatible with the C language's pointer (`T*`) types. So if you have an `extern "C"` Rust function, called from C, your Rust function can now use `Box<T>`, for some specific `T`, while using `T*` in C for the corresponding function. As an example, on the C side you may have:

```c
// C header */

// Returns ownership to the caller.
struct Foo* foo_new(void);

// Takes ownership from the caller; no-op when invoked with NULL.
void foo_delete(struct Foo*);
```

...while on the Rust side, you would have:

```rust
#[repr(C)]
pub struct Foo;

#[no_mangle]
pub extern "C" fn foo_new() -> Box<Foo> {
    Box::new(Foo)
}

// The possibility of NULL is represented with the `Option<_>`.
#[no_mangle]
pub extern "C" fn foo_delete(_: Option<Box<Foo>>) {}
```

Note however that while `Box<T>` and `T*` have the same representation and ABI, a `Box<T>` must still be non-null, aligned, and ready for deallocation by the global allocator. To ensure this, it is best to only use `Box`es originating from the global allocator.

**Important:** At least at present, you should avoid using `Box<T>` types for functions that are defined in C but invoked from Rust. In those cases, you should directly mirror the C types as closely as possible. Using types like `Box<T>` where the C definition is just using `T*` can lead to undefined behavior.

To read more, [consult the documentation for `Box<T>`](https://doc.rust-lang.org/std/boxed/index.html).

### Изменения в библиотеке

В версии Rust 1.41.0, мы сделали следующие изменения в стандартной библиотеке:

- Методы [`Result::map_or`](https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or) и [`Result::map_or_else`](https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or_else) теперь стабилизированы.

    Подобно [`Option::map_or`](https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or) и [`Option::map_or_else`](https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or_else), эти методы являются упрощением кода `.map(|val| process(val)).unwrap_or(default)`.

- [`NonZero*` числа теперь реализуют `From<NonZero*>` если их числовая длина меньше. ](https://github.com/rust-lang/rust/pull/66277) Например, `NonZeroU16` теперь реализует `From<NonZeroU8>`.

- Стабилизированы методы `weak_count` и `strong_count` структуры `Weak`.

    - [`std::rc::Weak::weak_count`](https://doc.rust-lang.org/std/rc/struct.Weak.html#method.weak_count)
    - [`std::rc::Weak::strong_count`](https://doc.rust-lang.org/std/rc/struct.Weak.html#method.strong_count)
    - [`std::sync::Weak::weak_count`](https://doc.rust-lang.org/std/sync/struct.Weak.html#method.weak_count)
    - [`std::sync::Weak::strong_count`](https://doc.rust-lang.org/std/sync/struct.Weak.html#method.strong_count)

    Эти методы возвращают количество слабых (`rc::Weak<T>` и `sync::Weak<T>`) или сильных (`Rc<T>` и `Arc<T>`) указателей на область памяти.

- [`MaybeUninit<T>` теперь реализует `fmt::Debug`.](https://github.com/rust-lang/rust/pull/65013)

### Сокращение поддержки 32-битной целевой платформы Apple

Rust 1.41.0 будет последеним выпуском с текущим уровнем поддержки 32-битных платформ Apple, включая `i686-apple-darwin`. Начиная с Rust 1.42.0 эти платформы будут понижены до самого низкого уровня поддержки.

[Узнать об этом больше вы можете в соответствующей записи в блоге.](https://blog.rust-lang.org/2020/01/03/reducing-support-for-32-bit-apple-targets.html)

### Другие изменения

[Синтаксис](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1410-2020-01-30), [пакетный менеджер Cargo](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-141-2020-01-30) и [анализатор Clippy](https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-141) также претерпели некоторые изменения. Мы также приступили к внедрению оптимизаций MIR, которые должны ускорить компиляцию: вы можете узнать о них в блоге ["Inside Rust"](https://blog.rust-lang.org/inside-rust/2019/12/02/const-prop-on-by-default.html).

## Участники 1.41.0

Множество людей собрались вместе, чтобы создать Rust 1.41.0. Мы не смогли бы сделать это без всех вас, [спасибо](https://thanks.rust-lang.org/rust/1.41.0/)!
