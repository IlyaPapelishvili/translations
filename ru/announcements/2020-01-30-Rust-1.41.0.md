The Rust team is happy to announce a new version of Rust, 1.41.0. Rust is a programming language that is empowering everyone to build reliable and efficient software.

If you have a previous version of Rust installed via rustup, getting Rust 1.41.0 is as easy as:

```console
rustup update stable
```

If you don't have it already, you can [get `rustup`](https://www.rust-lang.org/install.html) from the appropriate page on our website, and check out the [detailed release notes for 1.41.0](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1410-2020-01-30) on GitHub.

## Что вошло в стабильную версию 1.41.0

The highlights of Rust 1.41.0 include relaxed restrictions for trait implementations, improvements to `cargo install`, a more `git`-friendly `Cargo.lock`, and new FFI-related guarantees for `Box<T>`. See the [detailed release notes](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1410-2020-01-30) to learn about other changes not covered by this post.

### Relaxed restrictions when implementing traits

Для предотвращения поломок в экосистеме, когда зависимость добавляет новые реализации типажа, Rust использует [*orphan rule*](https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type). Суть в том, что реализация типажа допустима только если типаж или тип, который его реализует, является локальным, т.е. определённым в текущем крейте.  [Однако это достаточно сложно](https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence), когда используются обобщения.

Before Rust 1.41.0, the orphan rule was unnecessarily strict, getting in the way of composition. As an example, suppose your crate defines the `BetterVec<T>` struct, and you want a way to convert your struct to the standard library's `Vec<T>`. The code you would write is:

```rust
impl<T> From<BetterVec<T>> for Vec<T> {
    // ...
}
```

...which is an instance of the pattern:

```rust
impl<T> ForeignTrait<LocalType> for ForeignType<T> {
    // ...
}
```

In Rust 1.40.0 this `impl` was forbidden by the orphan rule, as both `From` and `Vec` are defined in the standard library, which is foreign to the current crate. There were ways to work around the limitation, such as [the *newtype* pattern](https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types), but they were often cumbersome or even impossible in some cases.

While it's still true that both `From` and `Vec` were foreign, the trait (in this case `From`) was parameterized by a local type. Therefore, Rust 1.41.0 allows this `impl`.

For more details, read the [the stabilization report](https://github.com/rust-lang/rust/issues/63599) and [the RFC proposing the change](https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html).

### `cargo install` updates packages when outdated

При помощи `cargo install` вы можете установить в систему исполняемый крейт. Эта команда часто используется для установки популярных CLI-инструментов, созданных комьюнити и написанных на Rust.

Начиная с Rust 1.41.0, `cargo install` также может обновлять установленные крейты, если с момента установки появился новый релиз. До этого выпуска единственным возможным вариантом было использование флага `--force`, который позволял переустановить исполняемый крейт даже если он не нуждался в обновлении.

### Менее конфликтный формат `Cargo.lock`

To ensure consistent builds, Cargo uses a file named `Cargo.lock`, containing dependency versions and checksums. Unfortunately, the way the data was arranged in it caused unnecessary merge conflicts when changing dependencies in separate branches.

Rust 1.41.0 представляет новый формат для этого файла, разработанный специально для уменьшения конфликтов. Новый формат будет использоваться для всех новых `lock`-файлов, в то время как существующие файлы будут использовать предыдущий формат. Узнать больше о вариантах, которые привели к новому формату, вы можете [в PR, в котором его добавили](https://github.com/rust-lang/cargo/pull/7070).

### More guarantees when using `Box<T>` in FFI

Starting with Rust 1.41.0, we have declared that a `Box<T>`, where `T: Sized` is now ABI compatible with the C language's pointer (`T*`) types. So if you have an `extern "C"` Rust function, called from C, your Rust function can now use `Box<T>`, for some specific `T`, while using `T*` in C for the corresponding function. As an example, on the C side you may have:

```c
// C header */

// Returns ownership to the caller.
struct Foo* foo_new(void);

// Takes ownership from the caller; no-op when invoked with NULL.
void foo_delete(struct Foo*);
```

...while on the Rust side, you would have:

```rust
#[repr(C)]
pub struct Foo;

#[no_mangle]
pub extern "C" fn foo_new() -> Box<Foo> {
    Box::new(Foo)
}

// The possibility of NULL is represented with the `Option<_>`.
#[no_mangle]
pub extern "C" fn foo_delete(_: Option<Box<Foo>>) {}
```

Note however that while `Box<T>` and `T*` have the same representation and ABI, a `Box<T>` must still be non-null, aligned, and ready for deallocation by the global allocator. To ensure this, it is best to only use `Box`es originating from the global allocator.

**Important:** At least at present, you should avoid using `Box<T>` types for functions that are defined in C but invoked from Rust. In those cases, you should directly mirror the C types as closely as possible. Using types like `Box<T>` where the C definition is just using `T*` can lead to undefined behavior.

To read more, [consult the documentation for `Box<T>`](https://doc.rust-lang.org/std/boxed/index.html).

### Library changes

In Rust 1.41.0, we've made the following additions to the standard library:

- The [`Result::map_or`](https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or) and [`Result::map_or_else`](https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or_else) methods were stabilized.

    Similar to [`Option::map_or`](https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or) and [`Option::map_or_else`](https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or_else), these methods are shorthands for the `.map(|val| process(val)).unwrap_or(default)` pattern.

- [`NonZero*` numerics now implement `From<NonZero*>` if it's a smaller integer width.](https://github.com/rust-lang/rust/pull/66277) For example, `NonZeroU16` now implements `From<NonZeroU8>`.

- Стабилизированы методы `weak_count` и `strong_count` структуры `Weak`.

    - [`std::rc::Weak::weak_count`](https://doc.rust-lang.org/std/rc/struct.Weak.html#method.weak_count)
    - [`std::rc::Weak::strong_count`](https://doc.rust-lang.org/std/rc/struct.Weak.html#method.strong_count)
    - [`std::sync::Weak::weak_count`](https://doc.rust-lang.org/std/sync/struct.Weak.html#method.weak_count)
    - [`std::sync::Weak::strong_count`](https://doc.rust-lang.org/std/sync/struct.Weak.html#method.strong_count)

    These methods return the number of weak (`rc::Weak<T>` and `sync::Weak<T>`) or strong (`Rc<T>` and `Arc<T>`) pointers to the allocation respectively.

- [`MaybeUninit<T>` now implements `fmt::Debug`.](https://github.com/rust-lang/rust/pull/65013)

### Сокращение поддержки 32-битной целевой платформы Apple

Rust 1.41.0 будет последеним выпуском с текущим уровнем поддержки 32-битных платформ Apple, включая `i686-apple-darwin`. Начиная с Rust 1.42.0 эти платформы будут понижены до самого низкого уровня поддержки.

[Узнать об этом больше вы можете в соответствующей записи в блоге.](https://blog.rust-lang.org/2020/01/03/reducing-support-for-32-bit-apple-targets.html)

### Другие изменения

[Синтаксис](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1410-2020-01-30), [пакетный менеджер Cargo](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-141-2020-01-30) и [анализатор Clippy](https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-141) также претерпели некоторые изменения. Мы также приступили к внедрению оптимизаций MIR, которые должны ускорить компиляцию: вы можете узнать о них в блоге ["Inside Rust"](https://blog.rust-lang.org/inside-rust/2019/12/02/const-prop-on-by-default.html).

## Участники 1.41.0

Множество людей собрались вместе, чтобы создать Rust 1.41.0. Мы не смогли бы сделать это без всех вас, [спасибо](https://thanks.rust-lang.org/rust/1.41.0/)!
