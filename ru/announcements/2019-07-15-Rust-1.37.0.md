Команда разработчиков Rust рада сообщить о выпуске новой версии, 1.37.0. Rust — это язык программирования, позволяющий каждому создавать надёжное и эффективное программное обеспечение.

Если вы установили предыдущую версию Rust средствами rustup, то для обновления до версии 1.37.0 вам достаточно выполнить следующую команду:

```console
$ rustup update stable
```

Если у вас ещё не установлен `rustup`, вы можете 
[установить его](https://www.rust-lang.org/install.html) с соответствующей страницы нашего 
веб-сайта, а также посмотреть [подробные примечания к выпуску](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1370-2019-08-15) на GitHub.

## Что вошло в стабильную версию?

Основные новшества в Rust 1.37.0 включают в себя ссылки на варианты перечисления (`enum`) через псевдонимы типов (`type`), встроенный `cargo vendor`,
неименованные константы (`const`), profile-guided optimization, ключ `default-run` для Cargo проектов и `#[repr(align(N))]` для перечислений. Для получения дополнительной информации ознакомьтесь с [подробными примечаниями к выпуску](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1370-2019-08-15).

### Referring to `enum` variants through `type` aliases

Начиная с Rust 1.37.0, ссылаться на варианты перечисления (`enum`) стало возможным через псевдонимы типов:

```rust
type ByteOption = Option<u8>;

fn increment_or_zero(x: ByteOption) -> u8 {
    match x {
        ByteOption::Some(y) => y + 1,
        ByteOption::None => 0,
    }
}
```

In implementations, `Self` acts like a type alias. So in Rust 1.37.0, you can also refer to `enum` variants with `Self::Variant`:

```rust
impl Coin {
    fn value_in_cents(&self) -> u8 {
        match self {
            Self::Penny => 1,
            Self::Nickel => 5,
            Self::Dime => 10,
            Self::Quarter => 25,
        }
    }
}
```

А точнее, теперь Rust позволяет ссылаться на варианты перечисления через *"type-relative resolution"*, `<MyType<..>>::Variant`. Более подробное описание доступно в [отчёте о стабилизации](https://github.com/rust-lang/rust/pull/61682/#issuecomment-502472847).

### Built-in Cargo support for vendored dependencies

After being available [as a separate crate](https://crates.io/crates/cargo-vendor) for years, the `cargo vendor` command is now integrated directly into Cargo. The command fetches all your project's dependencies unpacking them into the `vendor/` directory, and shows the configuration snippet required to use the vendored code during builds.

`cargo vendor` уже применяется в реальных проектах: компилятор Rust `rustc` использует его для отправки всех своих зависимостей в tar-архивы выпусков, а проекты с монорепозиториями используют его для фиксации кода зависимостей в системе управления версиями.

### Using unnamed `const` items for macros

Теперь вы можете создавать [неименованную (unnamed) константу (`const`)](https://github.com/rust-lang/rust/pull/61347/), подменив её идентификатор нижним подчёркиванием (`_`). Например, в компиляторе `rustc` мы нашли такой код:

```rust
/// Type size assertion where the first parameter
/// is a type and the second is the expected size.
#[macro_export]
macro_rules! static_assert_size {
    ($ty:ty, $size:expr) => {
        const _: [(); $size] = [(); ::std::mem::size_of::<$ty>()];
        //    ^ Note the underscore here.
    }
}

static_assert_size!(Option<Box<String>>, 8); // 1.
static_assert_size!(usize, 8); // 2.
```

Notice the second `static_assert_size!(..)`: thanks to the use of unnamed constants, you can define new items without naming conflicts. Previously you would have needed to write `static_assert_size!(MY_DUMMY_IDENTIFIER, usize, 8);`. Instead, with Rust 1.37.0, it now becomes easier to create ergonomic and reusable declarative and procedural macros for static analysis purposes.

### Profile-guided optimization

The `rustc` compiler now comes with [support for Profile-Guided Optimization (PGO)](https://github.com/rust-lang/rust/pull/61268/) via the `-C profile-generate` and `-C profile-use` flags.

[Profile-Guided Optimization](https://en.wikipedia.org/wiki/Profile-guided_optimization) allows the compiler to optimize code based on feedback from real workloads. It works by compiling the program to optimize in two steps:

1. Сперва программа создается средствами инструментария, встроенного в компилятор. Это делается путем передачи `rustc` флага `-C profile-generate`. Затем инструментальная программа должна быть запущена на образцах данных и впоследствии она запишет в файл данные профилирования.
2. Then, the program is built *again*, this time feeding the collected profiling data back into `rustc` by using the `-C profile-use` flag. This build will make use of the collected data to allow the compiler to make better decisions about code placement, inlining, and other optimizations.

For more in-depth information on Profile-Guided Optimization, please refer to the corresponding [chapter in the rustc book](https://doc.rust-lang.org/rustc/profile-guided-optimization.html).

### Выбор исполняемого файла в Cargo проектах

[`cargo run`](https://doc.rust-lang.org/cargo/commands/cargo-run.html) является весьма удобным инструментом для быстрого тестирования консольных приложений. Когда в одном пакете присутствует несколько исполняемых файлов, необходимо явно объявить имя того исполняемого файла, который вы хотите запустить при помощи флага `--bin`. Это делает `cargo run` не таким эргономичным, как хотелось бы, особенно когда определённый исполняемый файл вызывается чаще, чем другие.

Rust 1.37.0 addresses the issue by adding [`default-run`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-default-run-field), a new key in `Cargo.toml`. When the key is declared in the `[package]` section, `cargo run` will default to the chosen binary if the `--bin` flag is not passed.

### `#[repr(align(N))]` on `enum`s

Начиная с Rust 1.37.0, атрибут [`#[repr(align(N))]`](https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers) может быть использован для определения [выравнивания](https://doc.rust-lang.org/reference/type-layout.html#size-and-alignment) перечислений в памяти (ранее данный атрибут был разрешен только для структур (`struct`) и объединений (`union`)). Например, перечисление `Align16` будет, как и ожидалось, иметь выравнивание в `16` байт, тогда как естественное выравнивание без `#[repr(align(16))]` будет `4`:

```rust
#[repr(align(16))]
enum Align16 {
    Foo { foo: u32 },
    Bar { bar: u32 },
}
```

The semantics of using `#[repr(align(N))` on an `enum` is the same as defining a wrapper struct `AlignN<T>` with that alignment and then using `AlignN<MyEnum>`:

```rust
#[repr(align(N))]
struct AlignN<T>(T);
```

### Library changes

Rust 1.37.0 стабилизировал следующие компоненты стандартной библиотеки:

- [`BufReader::buffer`](https://doc.rust-lang.org/std/io/struct.BufReader.html#method.buffer) and [`BufWriter::buffer`](https://doc.rust-lang.org/std/io/struct.BufWriter.html#method.buffer)
- [`Cell::from_mut`](https://doc.rust-lang.org/std/cell/struct.Cell.html#method.from_mut)
- [`Cell::as_slice_of_cells`](https://doc.rust-lang.org/std/cell/struct.Cell.html#method.as_slice_of_cells)
- [`DoubleEndedIterator::nth_back`](https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html#method.nth_back)
- [`Option::xor`](https://doc.rust-lang.org/std/option/enum.Option.html#method.xor)
- [`{i,u}{8,16,64,128,size}::reverse_bits`](https://doc.rust-lang.org/std/primitive.u8.html#method.reverse_bits) and [`Wrapping::reverse_bits`](https://doc.rust-lang.org/std/num/struct.Wrapping.html#method.reverse_bits)
- [`slice::copy_within`](https://doc.rust-lang.org/std/primitive.slice.html#method.copy_within)

### Other changes

[Синтаксис](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1370-2019-08-15), [пакетный менеджер Cargo](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-137-2019-08-15) и [анализатор Clippy](https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-137) также претерпели некоторые изменения.

## Участники 1.37.0

Множество людей собрались вместе, чтобы создать Rust 1.37.0. Мы не смогли бы сделать это без всех вас, [спасибо!](https://thanks.rust-lang.org/rust/1.37.0/)

## New sponsors of Rust infrastructure

We'd like to thank two new sponsors of Rust's infrastructure who provided the resources needed to make Rust 1.37.0 happen: Amazon Web Services (AWS) and Microsoft Azure.

- AWS has provided hosting for release artifacts (compilers, libraries, tools, and source code), serving those artifacts to users through CloudFront, preventing regressions with Crater on EC2, and managing other Rust-related infrastructure hosted on AWS.
- Microsoft Azure has sponsored builders for Rust’s CI infrastructure, notably the extremely resource intensive rust-lang/rust repository.
