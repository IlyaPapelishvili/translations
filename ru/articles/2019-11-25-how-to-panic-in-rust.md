# Как работает паника в Rust

Что именно происходит, когда вы вызываете `panic!()`?
Недавно я потратил много времени на изучение частей стандартной библиотеки, связанных с этим и оказалось, что ответ довольно сложный!
Мне не удалось найти документы, объясняющие общую картину паники в Rust, так что это стоит записать.

<!-- MORE -->

(Бесстыдная статья: причина, по которой я заинтересовался этой темой, заключается в том что `@Aaron1011` реализовал поддержку раскручивания стека в Miri.
Я хотел увидеть это в Miri с незапамятных времен, и у меня никогда не было времени, чтобы реализовать это самому, поэтому было действительно здорово видеть, как кто-то просто отправляет `PR` для поддержки этого на ровном месте.
После большого количества раундов проверки кода, он был влит совсем недавно.
Всё ещё есть [некоторые грубые края](https://github.com/rust-lang/miri/issues?q=is%3Aissue+is%3Aopen+label%3AA-panics), но основы определены точно.)

Целью этой статьи является документирование структуры высокого уровня и соответствующих интерфейсов, которые вступают в игру на стороне Rust.
Фактический механизм разматывания - это совершенно другой вопрос (и тот, о котором я не имею права говорить).

*Примечание:* эта статья описывает панику с [этого коммита](https://github.com/rust-lang/rust/commit/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8).
Многие из описанных здесь интерфейсов являются нестабильными внутренними деталями libstd и могут измениться в любое время.

## Высокоуровневая структура

Пытаясь понять, как работает паника, читая код в libstd, можно легко потеряться в лабиринте.
Есть несколько уровней косвенности, которые соединяются только компоновщиком,
есть [атрибут `#[panic_handler]`](https://doc.rust-lang.org/nomicon/panic-handler.html) и [«время выполнения паники»](https://github.com/rust-lang/rfcs/blob/master/text/1513-less-unwinding.md) (контролируемое *стратегией* паники, которая устанавливается через `-C panic`) и [«ловушки паники»](https://doc.rust-lang.org/std/panic/fn.set_hook.html),
и оказывается, что паника в контексте `#[no_std]` требует совершенно другого пути к коду ... очень многое происходит.
Что ещё хуже, [RFC, описывающий ловушки паники](https://github.com/rust-lang/rfcs/blob/master/text/1328-global-panic-handler.md), называет их «обработчик паники», но этот термин с тех пор был переопределён.

Я думаю, что лучшее место для начала - это интерфейсы, управляющие двумя направлениями:

- *Среда выполнения паники* используется libstd для управления тем, что происходит после того, как информация о панике была напечатана в stderr.
    Это определяется *стратегией* паники: либо мы прерываем (`-C panic=abort`), либо запускаем размотку стэка (`-C panic=unwind`).
    (Среда выполнения паники также обеспечивает реализацию [`catch_unwind`](https://doc.rust-lang.org/std/panic/fn.catch_unwind.html), но здесь мы не будем говорить об этом.)

- *Обработчик паники* используется libcore для реализации (а) паники, вставляемой генерацией кода (такой как паника, вызванная арифметическим переполнением или индексацией массива/среза за пределами границ) и (b) `core::panic!` макрос (это макрос `panic!` в самой libcore и в `#[no_std]` контексте `#[no_std]`).

Оба эти интерфейса реализуются через `extern` блоки: listd/libcore, соответственно, просто импортируют некоторую функцию, которой они делегируют, и где-то совсем в другом месте в дереве крейтов эта функция реализуется.
Импорт разрешается только во время связывания; Глядя локально на этот код, нельзя сказать, где живёт фактическая реализация соответствующего интерфейса.
Неудивительно, что по пути я несколько раз терялся.

В дальнейшем оба этих интерфейса будут очень полезны; когда вы запутались, первое, что нужно проверить, это если вы просто перепутали *обработчик* паники и *время выполнения* паники.
(И помните, что есть также *перехватчики* паники, мы доберёмся до них.)
Это происходит со мной все время.

Более того, `core::panic!` и `std::panic!` *не* одинаковы; как мы увидим, они используют совершенно разные пути кода.
libcore и libstd каждый реализуют свой собственный способ вызвать панику:

- `core::panic!` из libcore очень мал: он всего лишь немедленно делегирует панику *обработчику*.

- libstd `std::panic!` («нормальный» макрос `panic!` в Rust) запускает полнофункциональный механизм паники, который обеспечивает управляемый пользователем [*перехват* паники](https://doc.rust-lang.org/std/panic/fn.set_hook.html).
    Хук по умолчанию выведет сообщение о панике в stderr.
    После того, как функция перехвата закончена, libstd делегирует  её обработчику паники *времени выполнения*.

    libstd также предоставляет *обработчик* паники, который вызывает тот же механизм, поэтому `core::panic!` также заканчивается здесь.

Давайте теперь посмотрим на эти части более подробно.

## Паника во время выполнения программы

[Интерфейс для среды выполнения паники](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/panicking.rs#L48) (представленный [этим RFC](https://github.com/rust-lang/rfcs/blob/master/text/1513-less-unwinding.md)) представляет собой функцию `__rust_start_panic(payload: usize) -> u32` которая импортируется libstd и позже разрешается компоновщиком.

Аргумент `usize` здесь на самом деле является `*mut &mut dyn core::panic::BoxMeUp` - это то место, где `*mut &mut dyn core::panic::BoxMeUp` «полезная нагрузка» паники (информация, доступная при ее обнаружении).
`BoxMeUp` - нестабильная внутренняя деталь реализации, но [глядя на этот типаж,](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libcore/panic.rs#L268-L271) мы видим, что все, что он действительно делает, это оборачивает `dyn Any + Send`, который является [типом полезной нагрузки паники,](https://doc.rust-lang.org/std/thread/type.Result.html) возвращаемой `catch_unwind` и `thread::spawn`.
`BoxMeUp::box_me_up` возвращает `Box<dyn Any + Send>`, но в виде необработанного указателя (поскольку `Box` недоступен в контексте, где определена этот типаж); `BoxMeUp::get` просто заимствует содержимое.

Две реализации этого интерфейса, с которыми [`libpanic_unwind`](https://github.com/rust-lang/rust/tree/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libpanic_unwind) Rust: [`libpanic_unwind`](https://github.com/rust-lang/rust/tree/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libpanic_unwind) для `-C panic=unwind` (по умолчанию на большинстве платформ) и [`libpanic_abort`](https://github.com/rust-lang/rust/tree/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libpanic_abort) для `-C panic=abort`.

## `Макрос std::panic!`

Помимо интерфейса *времени выполнения* паники, libstd реализует механизм паники Rust по умолчанию во внутреннем модуле [`std::panicking`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/panicking.rs).

#### `rust_panic_with_hook`

Ключевая функция, через которую проходит почти всё, - [`rust_panic_with_hook`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/panicking.rs#L435-L437):
```rust
fn rust_panic_with_hook(
payload: &mut dyn BoxMeUp,
message: Option<&fmt::Arguments<'_>>,
file_line_col: &(&str, u32, u32),
) -> !
```
Эта функция принимает местоположение источника паники, необязательное не отформатированное сообщение (см. Документацию [`fmt::Arguments`](https://doc.rust-lang.org/std/fmt/struct.Arguments.html)) и полезную нагрузку.

Его основная задача - вызывать то, чем является текущий перехватчик паники.
Перехватчики паники имеют аргумент [`PanicInfo`](https://doc.rust-lang.org/core/panic/struct.PanicInfo.html), поэтому нам нужно расположение источника паники, информация о формате для сообщения о панике и полезная нагрузка.
Это очень хорошо соответствует аргументу `rust_panic_with_hook`!
`file_line_col` и `message` могут использоваться непосредственно для первых двух элементов; `payload` превращается в `&(dyn Any + Send)` через интерфейс `BoxMeUp`.

Интересно, что *стандартный* перехватчик паники полностью игнорирует `message`; то что вы на самом деле видите напечатанным [ `payload` до `&str` или `String`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/panicking.rs#L171-L177) (что бы ни работало).
Предположительно, вызывающий должен убедиться, что форматирование `message`, если оно присутствует, дает тот же результат.
(И те, которые мы обсуждаем ниже, гарантируют это.)

Наконец, `rust_panic_with_hook` отправляется в текущий обработчик паники *времени выполнения*.
На данный момент, только `payload` по - прежнему актуальна - и что важно: `message` (как `'_` время жизни указывает, могут содержать короткоживущие ссылки, но полезная нагрузка паники будет распространяться вверх по стеку и, следовательно, должна быть `'static`).
`'static` граница там довольно хорошо скрыта, но через некоторое время я понял, что [`Any`](https://doc.rust-lang.org/std/any/trait.Any.html) подразумевает `'static` (и помните, что `dyn BoxMeUp` просто используется для получения `Box<dyn Any + Send>`).

#### Точки входа в libstd

`rust_panic_with_hook` - это закрытая функция для `std::panicking`; модуль предоставляет три точки входа поверх этой центральной функции и одну, которая её обходит:

- [Реализация обработчика паники](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/panicking.rs#L301) по [умолчанию](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/panicking.rs#L301), поддерживающая (как мы увидим) панику из `core::panic!` и встроенная паника (от арифметического переполнения или индексации массива/среза вне пределов).
    Получает в качестве входных данных [`PanicInfo`](https://doc.rust-lang.org/core/panic/struct.PanicInfo.html), и оно должно превратить это в аргументы для `rust_panic_with_hook`.
    Любопытно, что хотя компоненты `PanicInfo` и аргументы `rust_panic_with_hook` довольно хорошо совпадают, и кажется, что их можно просто переслать, это *не* то, что происходит.
    Вместо этого libstd полностью *игнорирует* компонент `payload` `PanicInfo` и устанавливает фактическую полезную нагрузку (переданную в `rust_panic_with_hook`) так, чтобы она содержала [отформатированное `message`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/panicking.rs#L348).

    В частности, это означает, что время *выполнения* паники не имеет значения для приложений `no_std`.
    Он вступает в игру только тогда, когда используется реализация обработчика паники в libstd.
    (*Стратегия* паники, выбранная через `-C panic` всё ещё имеет значение, поскольку она также влияет на генерацию кода.
    Например, с `-C panic=abort` код может стать проще, так как не нужно поддерживать раскручивание).

- [`begin_panic_fmt`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/panicking.rs#L319), поддержка [форматной строковой версии `std::panic!`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/macros.rs#L22-L23) (т.е. это используется, когда вы передаёте несколько аргументов макросу).
    Это в основном просто упаковывает аргументы строки формата в `PanicInfo` (с [фиктивной полезной нагрузкой](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libcore/panic.rs#L56) ) и вызывает обработчик паники по умолчанию, который мы только что обсуждали.

- [`begin_panic`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/panicking.rs#L388), поддерживающая [версию `std::panic!`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/macros.rs#L16) с [одним аргументом `std::panic!`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/macros.rs#L16).
    Интересно, что при этом используется совсем другой путь кода, чем в двух других точках входа!
    В частности, это единственная точка входа, которая позволяет передавать *произвольную полезную нагрузку*.
    Эта полезная нагрузка просто [преобразуется в `Box<dyn Any + Send>`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/panicking.rs#L415) чтобы его можно было передать в `rust_panic_with_hook`, и всё.

    В частности, перехватчик паники, который смотрит на `message` поле `PanicData`, *не* сможет увидеть сообщение в `std::panic!("do panic")`, но он *может* видеть сообщение в `std::panic!("panic with data: {}", data)` поскольку последний вместо этого проходит через `begin_panic_fmt`.
    Это кажется довольно удивительным. (Но также обратите внимание, что `PanicData::message()` еще не стабильна.)

- [`update_count_then_panic`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/panicking.rs#L488) нечетный: эта точка входа поддерживает [`resume_unwind`](https://doc.rust-lang.org/nightly/std/panic/fn.resume_unwind.html) и фактически *не* вызывает перехват паники.
    Вместо этого немедленно отправляется в обработчик паники.
    Например, `begin_panic`, он позволяет вызывающей стороне выбирать произвольную полезную нагрузку.
    В отличие от `begin_panic`, вызывающая функцию `begin_panic` отвечает за упаковку и определение размера полезной нагрузки; `update_count_then_panic` просто пересылает этот почти дословно во время выполнения паники.

## Обработчик паники

`std::panic!` механизм действительно полезен, но он зависит от распределения кучи через `Box` что не всегда доступно.
Чтобы дать libcore способ вызывать панику, были введены [обработчики паники](https://github.com/rust-lang/rfcs/blob/master/text/2070-panic-implementation.md).
Как мы уже видели, если libstd доступен, он обеспечивает реализацию этого интерфейса `core::panic!` панику в представлениях libstd.

[Интерфейс для обработчика паники](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libcore/panicking.rs#L78) - это функция `fn panic(info: &core::panic::PanicInfo) -> !` libcore импортирует, и это позже разрешается компоновщиком.
Тип [`PanicInfo`](https://doc.rust-lang.org/core/panic/struct.PanicInfo.html) такой же, как и для перехватчиков паники: он содержит местоположение источника паники, сообщение о панике и полезную нагрузку (`dyn Any + Send`).
Сообщение о панике представляется в виде [`fmt::Arguments`](https://doc.rust-lang.org/std/fmt/struct.Arguments.html), то есть строки форматирования с аргументами, которая еще не была отформатирована.

## `Макрос core::panic!`

Помимо интерфейса обработчика паники, libcore предоставляет [минимальный API паники](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libcore/panicking.rs).
[`core::panic!`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libcore/macros/mod.rs#L10-L26) макрос создает `fmt::Arguments` который затем [передается обработчику паники](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libcore/panicking.rs#L82).
Здесь не происходит форматирование, так как это потребует выделения памяти в куче; Вот почему `PanicInfo` содержит «неинтерпретированную» строку формата со своими аргументами.

Любопытно, что поле `payload` `PanicInfo` которое передается обработчику паники, всегда устанавливается на [фиктивное значение](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libcore/panic.rs#L56).
Это объясняет, почему обработчик паники libstd игнорирует полезную нагрузку (и вместо этого создает новую полезную нагрузку из `message`), но это заставляет меня задуматься, почему это поле является частью API обработчика паники.
Другим следствием этого является то, что [`core::panic!("message")`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libcore/macros/mod.rs#L15) и [`std::panic!("message")`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libstd/macros.rs#L16) (варианты без какого-либо форматирования) на самом деле приводят к очень разным паникам: первый превращается в `fmt::Arguments`, передается через интерфейс обработчика паники, а затем libstd создает полезную нагрузку `String` путем ее форматирования.
Последний, однако напрямую использует `&str` в качестве полезной нагрузки, и поле `message` остается `None` (как уже упоминалось).

Некоторые элементы API паники в libcore являются элементами языка, потому что компилятор вставляет вызовы этих функций во время генерации кода:

- Элемент [языка `panic`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libcore/panicking.rs#L39) вызывается, когда компилятору нужно вызвать панику, которая не требует какого-либо форматирования (например, арифметического переполнения); это та же самая функция, которая также поддерживает [`core::panic!`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libcore/macros/mod.rs#L15) одним аргументом [`core::panic!`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libcore/macros/mod.rs#L15).
- [Элемент языка `panic_bounds_check`](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libcore/panicking.rs#L55) вызывается при неудачной проверке границ массива/среза.Он вызывает тот же метод, что и [`core::panic!` с форматированием](https://github.com/rust-lang/rust/blob/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8/src/libcore/panicking.rs#L55).

## Выводы

Мы прошли через 4 уровня API, 2 из которых были перенаправлены через импортированные вызовы функций и разрешены компоновщиком.
Вот это путешествие!
Но мы достигли конца.
Я надеюсь, что вы [не паниковали](https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Don't_Panic) по пути. ;)

Я упомянул некоторые вещи как удивительные.
Оказывается, все они связаны с тем фактом, что перехватчики паники и обработчики паники разделяют структуру `PanicInfo` в своем интерфейсе, который содержит *как* необязательное ещё не отформатированное `message` и `payload` стёртым типом:

- Паника *перехватчик* всегда может найти уже отформатированное сообщение в `payload`, поэтому `message` кажется бессмысленным для перехватчиков.Фактически, `message` может отсутствовать, даже если `payload` содержит сообщение (например, для `std::panic!("message")`).
- *Обработчик* паники никогда не будет на самом деле получить полезную `payload`, так что поле кажется бессмысленным для обработчиков.

Читая [RFC по описанию обработчика паники](https://github.com/rust-lang/rfcs/blob/master/text/2070-panic-implementation.md), кажется, что план был для `core::panic!` также поддерживать произвольные полезные нагрузки, но до сих пор это не материализовалось.
Тем не менее, даже с этим будущим расширением, я думаю, у нас есть инвариант, что когда `message` имеет значение `Some`, тогда либо `payload == &NoPayload` (поэтому полезная нагрузка избыточна), либо `payload` является форматированным сообщением (поэтому сообщение избыточно).
Интересно, есть ли случай, когда *оба* поля будут полезны и если нет, то можем ли мы закодировать это, сделав их двумя вариантами `enum`?
Вероятно, есть веские причины против этого предложения и для нынешнего дизайна; было бы здорово получить их где-нибудь задокументировано. :)

Есть еще много чего сказать, но на этом этапе я приглашаю вас перейти по ссылкам на исходный код, который я включил выше.
Имея в виду структуру высокого уровня, вы должны быть в состоянии следовать этому коду.
Если бы люди думали, что этот обзор стоил бы поместить куда-то навсегда, я был бы рад превратить эту статью в блог в какую-то документацию - хотя я не уверен, что это было бы хорошим местом.
И если вы обнаружите какие-либо ошибки в том, что я написал, пожалуйста, дайте мне знать!
